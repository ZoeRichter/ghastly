import numpy as np
import openmc
import ghastly
from jinja2 import Environment, PackageLoader
from ghastly import read_input
from ghastly import region

env = Environment(loader=PackageLoader('ghastly', 'templates'))


def fill_core_lmp(input_file, rough_pf, 
                  fill_file = "fill_main.txt",
                  fill_template = "lammps/fillmain_template.txt",
                  dump_file = "rough-pack.txt",
                  variable_file = "fill_variables.txt",
                  variable_template = "lammps/variable_template.txt",
                  crp = False, openmc = False, verbose = True):
    '''
    This function "roughly" packs the full core region defined by the Ghastly 
    input file, then uses a series of Jinja templates to create a LAMMPS 
    input file that will run a physics simulation, modeling not only the 
    settling of the roughly packed pebbles due to gravtiy, but also handle 
    the addtion of any extra pebbles needed to reach the target number of 
    pebbles needed.

    Parameters
    ----------
    input_file : str
        Name of ghastly input file, which should be in JSON format, following
        the layout and parameter naming convention given in the example inputs.
    rough_pf : float
        Packing fraction used in OpenMC packing function.  Choosing a rough_pf
        greater than the target pf in the input file can result in overfilling
        of the core, and so it is reccommended to use a rough_pf that is
        less than or equal to the desired final pf.
    fill_file : str
        bleh
    fill_template : str
        bleh
    dump_file : str
        bleh
    variable_file : str
        blah
    variable_template : str
        bleh
    crp : bool
        bleh
    openmc : bool
        bleh

    Returns
    -------
    While this function does not have a return at its completion, it will
    generate a number of input files for LAMMPS.
    '''

    input_block = read_input.InputBlock(input_file)
    sim_block = input_block.create_obj()

    rough_pack = []
    match sim_block.down_flow:
        case True:
            pack_zones = sim_block.core_main | sim_block.core_outlet
        case False:
            pack_zones = sim_block.core_main | sim_block.core_inlet

    for element in pack_zones.values():
        coords = _pack_cyl(sim_block, element, rough_pf, crp, openmc)
        rough_pack += coords

    outlet_vol = sum([i.volume for i in sim_block.core_outlet.values()])
    main_vol = sum([i.volume for i in sim_block.core_main.values()])
    n_pebbles = int(np.floor((0.60*outlet_vol)/sim_block.pebble_volume) +
                    np.floor((sim_block.pf*main_vol)/sim_block.pebble_volume))
    if verbose:
        print("Target number of pebbles is "+str(n_pebbles))

    pebbles_left = n_pebbles - len(rough_pack)

    if pebbles_left < 0:
        raise ValueError('''Rough pack overfilled the core.  Reduce
                         rough_pf and try again.''')

    bound_limits = find_box_bounds(sim_block, pour=True)

    write_lammps_dump_file(rough_pack, "ff ff ff", bound_limits, dump_file)

    _write_variable_block(input_block, sim_block, 
                          variable_file, variable_template)

    reg_files, reg_names = _write_region_blocks(pack_zones)

    match sim_block.down_flow:
        case True:
            settle = ""
        case _:
            _write_settle_block("settle.txt", sim_block, reg_names)
            settle = "include           settle.txt"

    params = {'variable_file':variable_file,
              'region_files' : reg_files,
              'region_names' : reg_names,
              'n_regions' : len(reg_names),
              'pebbles_left' : pebbles_left,
              'settle' : settle} | bound_limits
    _templater(params, fillmain_file, fillmain_template)


def _pack_cyl(sim_block, element, rough_pf, crp, openmc):
    '''
    Generates coords for a rough-pack of the given core element.  The default
    behavior is to generate a series of points assuming a simple cubic lattice.
    Users with OpenMC may instead use the crp and openmc flags to use
    OpenMC's Jodrey-Tory algorithm implementation.

    Parameters
    ----------
    sim_block : ghastly Sim object
        Sim class object that contains simulation-specific simulation,
        read from input_file.
    element : ghastly Core object
        Core object for a portion of the core model.  Note that OpenMC cannot
        randomly pack conical containers at this time.  The default method can
        pack cones.
    rough_pf : float
        Target packing fraction for the initial rough pack (only useful if
        using OpenMC).
    crp : bool
        bleh
    openmc : bool
        bleh

    Returns
    -------
    coords : list
        List of pebble centroid coordinates generated by OpenMC, within a
        cylindrical region matching the core element passed to pack_cyl.
    '''

    if crp == True:
        assert openmc == True

        if type(element) == ghastly.core.CylCore:
            sides = openmc.ZCylinder(x0=element.x_c,
                                     y0=element.y_c,
                                     r=element.r)
            top = openmc.ZPlane(z0=element.zmax)
            bottom = openmc.ZPlane(z0=element.zmin)
            region_bounds = -sides & -top & +bottom

            points = openmc.model.pack_spheres(sim_block.r_pebble,
                                               region=region_bounds,
                                               pf=rough_pf,
                                               contraction_rate=sim_block.k_rate)
            coords = list(points)
        else:
            coords = []
    
    else:
        coords = []
        r_sph = sim_block.r_pebble + (0.05*sim_block.r_pebble)
        center = (element.x_c, element.y_c, (element.zmax-element.zmin)/2)
        match type(element):
            case  ghastly.core.CylCore:
                r = element.r
                lim = {'z':[element.zmin+r_sph, element.zmax-r_sph],
                       'r':[(0, 0), (0, r - r_sph)]}
            case ghastly.core.ConeCore:
                r = element.r_major
                m = element.h/(element.r_major - element.r_minor)
                lim = {'z':[element.zmin+r_sph, element.zmax-r_sph],
                       'r':[(0, 0), (1/m, element.r_minor 
                                     - (r_sph/m)*(m**2+1)**0.5 
                                     - (center[2] - element.h/2)/m)]}

        nx = (2*r)/r_sph
        ny = (2*r)/r_sph
        nz = element.h/r_sph
        x = np.linspace(element.x_c - r, element.x_c + r, nx)
        y = np.linspace(element.y_c - r, element.y_c + r, ny)
        z = np.linspace(element.zmin, element.zmax, nz)
        points = [np.array([xi, yi, zi]) for xi in x for yi in y for zi in z]
        for p in points:
            radius = ((p[0] - center[0])**2 + (p[1] - center[1])**2)**0.5
            r_lim = lim['r'][1][0]*p[2] + lim['r'][1][1]
            if radius <= r_lim and p[2] >= lim['z'][0] and p[2] <= lim['z'][1]:
                coords += [p]

    return coords


def find_box_bounds(sim_block, pour=False):
    '''
    Using the core_zones contained in the sim_block, this function
    uses the dimensions of all core elements in the model to determine the
    appropriate size of the bounding box used in LAMMPS simulations.
    Note that when used to determine the bounding box for a simulation
    using the pour LAMMPS fix, the bounding box is extended in the
    positive z-direction, to allow for a temporary insertion region to
    be added.

    Parameters
    ----------
    sim_block : Sim object
        Sim object created from parameters in the input file for ghastly.
    pour : bool
        Default False.  Whether or not the LAMMPS simulation the bounds
        are being generated for is using the pour fix in LAMMPS.

    Returns
    -------
    bound_limits : dict
        Dictionary with key:value pairs in the form of
        {'xb_min':xmin, 'xb_max':xmax, ... , 'zb_max':zmax}
    '''

    core_list = (sim_block.core_inlet |
                 sim_block.core_main |
                 sim_block.core_outlet)
    x_list = []
    y_list = []
    z_list = []
    for element in core_list.values():
        z_list += [element.zmin, element.zmax]
        if type(element) == ghastly.core.CylCore:
            x_list += [(element.x_c - element.r),
                       (element.x_c + element.r)]
            y_list += [(element.y_c - element.r),
                       (element.y_c + element.r)]
        elif type(element) == ghastly.core.ConeCore:
            x_list += [(element.x_c - element.r_major),
                       (element.x_c + element.r_major),
                       (element.x_c - element.r_minor),
                       (element.x_c + element.r_minor)]
            y_list += [(element.y_c - element.r_major),
                       (element.y_c + element.r_major),
                       (element.y_c - element.r_minor),
                       (element.y_c + element.r_minor)]
    f = 5.0
    match pour:
        case True:
            f_zup = 10.0
        case _:
            f_zup = 5.0
    bound_limits = {'xb_min' : min(x_list) - f*sim_block.r_pebble,
                    'xb_max' : max(x_list) + f*sim_block.r_pebble,
                    'yb_min' : min(y_list) - f*sim_block.r_pebble,
                    'yb_max' : max(y_list) + f*sim_block.r_pebble,
                    'zb_min' : min(z_list) - f*sim_block.r_pebble,
                    'zb_max' : max(z_list) + f_zup*sim_block.r_pebble}

    return bound_limits

def recirc_pebbles(input_file, init_bed_file, recirc_file, recirc_template,
                   variable_file = "variables.txt", 
                   variable_template = "lammps/variable_template.txt",
                   velreg_file = "velreg.txt", 
                   velreg_template = "lammps/velreg_template.txt",
                   siminit_file = "siminit_file.txt",
                   siminit_template = "lammps/siminit_template.txt",
                   f2outlet_file = "f2outlet.txt",
                   f2outlet_template = "lammps/f2outlet_template.txt"):
    '''
    Reads Ghastly input_file in order to generate a LAMMPS input file
    that will recirculate pebbles at the desired level of fidelity

    Parameters
    ----------
    input_file : str
        Path to input_file to be used, containing user-defined parameters for
        a Ghastly recirculation simulation
    init_bed_file : str
        Path to the LAMMPS dump file that contains the
        id, type, and x y z centroid coordinates of each pebble in the
        initial pebble bed, which should be settled, and filled to the desired
        packing fraction.  Note that the write_lammps_dump_file function can
        be used to generate an appropriately-formatted LAMMPS dump file from
        an numpy array of pebble centroid coordinates.
    recirc_file : str
        Filename for the main LAMMPS input file Ghastly generates.
    recirc_template : str
        Filename of the main recirculation template.  Note that
        custom templates should be located in the ghastly/templates/
        directory.
    variable_file : str
        Optional. File name for LAMMPS variable block file generated by
        Ghastly.
    variable_template : str
        bleh
    velreg_file : str
        bleh
    velreg_template : str
        bleh
    siminit_file : str
        bleh
    siminit_template : str
        bleh
    f2outlet_file : str
        bleh
    f2outlet_template : str
        bleh

    Returns
    ----------
    This function does not return any values, but it will generate a series
    of output files.  The one that should be run in order to start the
    recirculation simulation is recirc_file.
    '''
    input_block = read_input.InputBlock(input_file)
    sim_block = input_block.create_obj()

    bound_limits = find_box_bounds(sim_block)

    _write_variable_block(variable_file, input_block, sim_block)
    _templater({}, velreg_file, velreg_template)
    _templater({}, siminit_file, siminit_template)

    vessel = (sim_block.core_inlet |
              sim_block.core_main |
              sim_block.core_outlet)
    reg_files, reg_names = write_region_blocks(vessel)

    params = {'variable_file' : variable_file,
              'region_files' : reg_files,
              'region_names' : reg_names,
              'n_regions' : len(reg_names),
              'velreg_file' : velreg_file,
              'starting_bed' : init_bed_file,
              'siminit_file' : siminit_file} | bound_limits

    elif sim_block.fidelity == 2:
        _write_f2outlet(sim_block, f2outlet_file, f2outlet_template)
        params['f2outlet_file'] = f2outlet_file

    _templater(params, recirc_file, recirc_template)
    return sim_block



def write_lammps_dump_file(coords, bound_conds, bound_limits, dump_file,
                           timestep = 0,
                           dump_template = "lammps/dump_template.txt"):
    '''
    Using the coordinate array and simulation boundary conditions and
    dimentions, this function uses a jinja template
    to create a LAMMPS dumpfile that be read into LAMMPS.

    Parameters
    ----------
    coords : list
        List of pebble centroid coordinates.
    dump_file : str
        Desired name of LAMMPS dumpfile created.  Please see LAMMPS read dump
        documentation for a full list of acceptable dump file types.
    bound_conds : str
        String providing the exact surface boundary conditions to be used
        in the LAMMPS bounding box.  See LAMMPS documentation for more
        information on bounding box conditions.
    bound_limits : dict
        Dictionary with key:value pairs in the form of 
        {'xb_min':xmin, 'xb_max':xmax, ... , 'zb_max':zmax}
    timestep : int
        Timestep to use inside dump file.  Default is 0.
    dump_template : string
        File name for template to be used.  Default is lammps/dump_template.txt

    Returns
    -------
    dump_file : file
        Generated file with the same name as dump_file.
    '''

    pebble_coords = [{"id": i, "x": v[0], "y": v[1], "z": v[2]}
                     for i, v in enumerate(coords)]
    params = {'timestep' : timestep,
              'boundary' : bound_conds,
              'coords' : pebble_coords,
              'n_pebbles' : len(coords)} | bound_limits
    _templater(params, dump_file, dump_template)

    return


def _write_variable_block(input_block, sim_block, 
                          variable_file, variable_template):
    '''
    Create the file containing LAMMPS variables, which can later be included
    in a main LAMMPS input.

    Parameters
    ----------
    variable_file : str
        The name of the variable block file to be created.
    variable_template : str
        bleh
    input_block : Ghastly InputBlock object
        Ghastly object made from reading a Ghastly input file.
    sim_block : Ghastly Sim object
        Object containing simulation-specific information.

    Returns
    -------
    variable_file : file
        Generated file with the same name as variable_file.
    '''

    vessel = (sim_block.core_main |sim_block.core_outlet)

    r_vessel = max([element.r for element in vessel.values() 
                    if type(element) == ghastly.core.CylCore])
    vessel_zmax = max([element.zmax for element in vessel.values() 
                       if type(element) == ghastly.core.CylCore])
    vessel_zmin = min([element.z_min for element in vessel.values() 
                       if type(element) == ghastly.core.CylCore])
    vessel_x_c, vessel_y_c = [(element.x_c, element.y_c) for element 
                              in sim_block.core_main.values() 
                              if type(element) == ghastly.core.CylCore][0]

    variables = input_block.lammps_var
    variables["t_final"] = sim_block.t_final
    variables["r_pebble"] = sim_block.r_pebble
    variables["vessel_zmin"] = vessel_zmin
    variables["vessel_zmax"] = vessel_zmax
    variables["vessel_x_c"] = vessel_x_c
    variables["vessel_y_c"] = vessel_y_c
    variables["seed"] = sim_block.seed
    variables["recirc_target"] = sim_block.recirc_target
    variables["recirc_hz"] = sim_block.recirc_hz

    params = {}
    params['var_list'] = variables.items()

    _templater(params, variable_file, variable_template)



def _write_region_blocks(core_zones,
                         cyl_template = "lammps/cyl_template",
                         cone_template = "lammps/cone_template"):
    '''
    Creates region block LAMMPS files for each core element in the core zones
    passed to this function, which can be included in a main LAMMPS file.

    Parameters
    ----------
    core_zones : dict
        Dictionary with key:value pairs where each key is the name of a core
        element, and each value is a Ghastly Core object containing that
        element's parameters.
    cyl_template : str
        bleh
    cone_template : str
        bleh

    Returns
    -------
    reg_files : list
        List of the files for each region block generated.
    reg_names : list
        List of the element names for each region block generated, which is
        used as the region's name in LAMMPS.
    '''

    reg_files = []
    reg_names = []
    for element_name, element in core_zones.items():
        reg_names.append(str(element_name))
        reg_file = str(element_name)+"_region.txt"
        reg_files.append(reg_file)
        params = {'name' : element_name,
                  'x_c' : element.x_c,
                  'y_c' : element.y_c,
                  'zmin' : element.zmin,
                  'zmax' : element.zmax,
                  'open_bottom' : element.open_bottom,
                  'open_top' : element.open_top}
        if type(element) == ghastly.core.CylCore:
            params['r'] = element.r
            _templater(params, reg_file, cyl_template)

        elif type(element) == ghastly.core.ConeCore:
            params['r_major'] = element.r_major
            params['r_minor'] = element.r_minor
            _templater(params, reg_file, cone_template)

        else:
            raise TypeError(str(element_name)+" is not a CylCore or ConeCore.")
    return reg_files, reg_names


def _write_settle_block(settle_file, sim_block, reg_names):
    '''
    Write lammps code block that adds the outlet region to the simulation
    and reverses gravity, allowing pebbles to settle upwards after pouring
    for upwards flowing systems.

    Parameters
    ----------
    settle_file : str
        Name of the LAMMPS input file that will be created.
    sim_block : Ghastly Sim object
        Ghastly Sim object containing simulation-specific parameters.
        Generally created automatically from an input file.
    reg_names : list
        List of strings, where each string is the ID of the region
        corresponding to the region file with the same index in reg_files.

    Returns
    -------
    settle_file : file
        Generated file with the same name as settle_file.
    '''

    outlet_files, outlet_names = _write_region_blocks(sim_block.core_outlet)
    outlet_names += reg_names

    params = {'outlet_files': outlet_files,
              'n_regions' : len(outlet_names),
              'region_names' : outlet_names}
    _templater(params, settle_file, "lammps/settle_template.txt")


def _write_f2outlet(sim_block, f2outlet_file, f2outlet_template):
    '''
    Writes file for the recirculation region used to select which pebbles
    should be recirculated each loop in LAMMPS.  This region is non-physical.

    Parameters
    ----------
    sim_block : ghastly Sim object
        bleh
    f2outlet_file : str
        file name of the recirculation outlet zone region block.
    f2outlet_template : str
        bleh

    Returns
    ----------
    This function has no return, but does generate a file named outlet_file.
    '''

    f2outlet_zmin = min([element.z_min for element 
                       in sim_block.core_outlet.values() 
                       if type(element) == ghastly.core.CylCore])
    f2outlet_zmax = f2outlet_zmin + 2*(sim_block.r_pebble)
    x_c, y_c = [(element.x_c, element.y_c) for element 
                in sim_block.core_outlet.values() 
                if type(element) == ghastly.core.CylCore][0]
    params = {'x_c' : x_c,
              'y_c' : y_c,
              'zmin' : f2outlet_zmin,
              'zmax' : f2outlet_zmax}

    _templater(params, f2outlet_file, f2outlet_template)


def _write_velreg(sim_block, velreg_file, velreg_template):
    '''
    Writes a file containing region blocks used for dumping velocity
    information by-region in the main core.  These are non-physical regions.

    Parameters
    ----------
    sim_block : 
        bleh
    velreg_file: str
        Filename of the velocity region input block file that this function
        generates.
    velreg_template : str
        bleh

    Returns
    ----------
    This function has no returns, but does generate a file named velreg_file.
    '''
    
    vessel = (sim_block.core_main |sim_block.core_outlet)

    r_vessel = max([element.r for element in vessel.values() 
                   if type(element) == ghastly.core.CylCore])
    velreg_zmax = max([element.zmax for element in vessel.values() 
                   if type(element) == ghastly.core.CylCore])
    velreg_zmin = min([element.z_min for element in vessel.values() 
                       if type(element) == ghastly.core.CylCore])
    x_c, y_c = [(element.x_c, element.y_c) for element 
                in sim_block.core_main.values() 
                if type(element) == ghastly.core.CylCore][0]

    params = {'r_vessel' : r_vessel,
              'zmin' : velreg_zmin,
              'zmax' : velreg_zmax,
              'x_c' : x_c,
              'y_c' : y_c}

    _templater(params, velreg_file, velreg_template)

def _templater(params, template_name, file):
    '''
    given parameter dict and template file name, render and write file

    Parameters
    ----------
    params : dict
        bleh
    file : str
        bleh
    template_name : str
        bleh

    Returns
    ----------
    '''
    
    template = env.get_template(template_name)
    text = template.render(params)
    with open(file, mode='w') as f:
        f.write(text)
    return text



    


