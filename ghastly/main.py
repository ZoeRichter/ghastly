import numpy as np
import openmc
import ghastly
from jinja2 import Environment, PackageLoader
from ghastly import read_input
from ghastly import region
from lammps import lammps

env = Environment(loader=PackageLoader('ghastly', 'templates'))


def fill_core_lmp(input_file, rough_pf, 
              pour_file = "pour_main.txt", dump_file = "rough-pack.txt",
              variable_file = "pour_variables.txt", 
              crp = False, openmc = False):
    '''
    This function "roughly" packs the full core region defined by the Ghastly 
    input file, then uses a series of Jinja templates to create a LAMMPS 
    input file that will run a physics simulation, modeling not only the 
    settling of the roughly packed pebbles due to gravtiy, but also handle 
    the addtion of any extra pebbles needed to reach the target number of 
    pebbles needed.

    Parameters
    ----------
    input_file : str
        Name of ghastly input file, which should be in JSON format, following
        the layout and parameter naming convention given in the example inputs.
    rough_pf : float
        Packing fraction used in OpenMC packing function.  Choosing a rough_pf
        greater than the target pf in the input file can result in overfilling
        of the core, and so it is reccommended to use a rough_pf that is
        less than or equal to the desired final pf.

    Returns
    -------
    While this function does not have a return at its completion, it will
    generate a number of files - both LAMMPS input files and files LAMMPS
    itself will generate.  For that reason, it's recommended that this be
    run inside its own directory, in order to keep these files organized.
    '''

    input_block = read_input.InputBlock(input_file)
    sim_block = input_block.create_obj()

    rough_pack = []
    match sim_block.down_flow:
        case True:
            pack_zones = sim_block.core_main | sim_block.core_outlet
        case False:
            pack_zones = sim_block.core_main | sim_block.core_inlet

    for element in pack_zones.values():
        coords = _pack_cyl(sim_block, element, rough_pf, crp, openmc)
        rough_pack += coords

    outlet_vol = sum([i.volume for i in sim_block.core_outlet.values()])
    main_vol = sum([i.volume for i in sim_block.core_main.values()])
    n_pebbles = int(np.floor((0.60*outlet_vol)/sim_block.pebble_volume) +
                    np.floor((sim_block.pf*main_vol)/sim_block.pebble_volume))
    print("Target number of pebbles is "+str(n_pebbles))

    pebbles_left = n_pebbles - len(rough_pack)

    if pebbles_left < 0:
        raise ValueError('''Rough pack overfilled the core.  Reduce
                         rough_pf and try again.''')

    bound_limits = find_box_bounds(sim_block, pour=True)

    write_lammps_dump_file(rough_pack, "ff ff ff", bound_limits, 
                           dump_file)

    _write_variable_block(variable_file, input_block, sim_block)

    reg_files, reg_names = _write_region_blocks(pack_zones)

    _write_pour_main(pour_file, sim_block, variable_file, bound_limits,
                    reg_files, reg_names, pebbles_left)


def _pack_cyl(sim_block, element, rough_pf, crp, openmc):
    '''
    Generates coords for a rough-pack of the given core element.  The default
    behavior is to generate a series of points assuming a simple cubic lattice.
    Users with OpenMC may instead use the crp and openmc flags to use
    OpenMC's Jodrey-Tory algorithm implementation.

    Parameters
    ----------
    sim_block : ghastly Sim object
        Sim class object that contains simulation-specific simulation,
        read from input_file.
    element : ghastly Core object
        Core object for a portion of the core model.  Note that OpenMC cannot
        randomly pack conical containers at this time.  The default method can
        pack cones.
    rough_pf : float
        Target packing fraction for the initial rough pack (only useful if
        using OpenMC).

    Returns
    -------
    coords : list
        List of pebble centroid coordinates generated by OpenMC, within a
        cylindrical region matching the core element passed to pack_cyl.
    '''

    if crp == True:
        assert openmc == True

        if type(element) == ghastly.core.CylCore:
            sides = openmc.ZCylinder(x0=element.x_c,
                                     y0=element.y_c,
                                     r=element.r)
            top = openmc.ZPlane(z0=element.zmax)
            bottom = openmc.ZPlane(z0=element.zmin)
            region_bounds = -sides & -top & +bottom

            points = openmc.model.pack_spheres(sim_block.r_pebble,
                                               region=region_bounds,
                                               pf=rough_pf,
                                               contraction_rate=sim_block.k_rate)
            coords = list(points)
        else:
            coords = []
    
    else:
        coords = []
        r_sph = sim_block.r_pebble + (0.05*sim_block.r_pebble)
        center = (element.x_c, element.y_c, (element.zmax-element.zmin)/2)
        match type(element):
            case  ghastly.core.CylCore:
                r = element.r
                lim = {'z':[element.zmin+r_sph, element.zmax-r_sph],
                       'r':[(0, 0), (0, r - r_sph)]}
            case ghastly.core.ConeCore:
                r = element.r_major
                m = element.h/(element.r_major - element.r_minor)
                lim = {'z':[element.zmin+r_sph, element.zmax-r_sph],
                       'r':[(0, 0), (1/m, element.r_minor 
                                     - (r_sph/m)*(m**2+1)**0.5 
                                     - (center[2] - element.h/2)/m)]}

        nx = (2*r)/r_sph
        ny = (2*r)/r_sph
        nz = element.h/r_sph
        x = np.linspace(element.x_c - r, element.x_c + r, nx)
        y = np.linspace(element.y_c - r, element.y_c + r, ny)
        z = np.linspace(element.zmin, element.zmax, nz)
        points = [np.array([xi, yi, zi]) for xi in x for yi in y for zi in z]
        for p in points:
            radius = ((p[0] - center[0])**2 + (p[1] - center[1])**2)**0.5
            r_lim = lim['r'][1][0]*p[2] + lim['r'][1][1]
            if radius <= r_lim and p[2] >= lim['z'][0] and p[2] <= lim['z'][1]:
                coords += [p]

    return coords


def find_box_bounds(sim_block, pour=False):
    '''
    Using the core_zones contained in the sim_block, this function
    uses the dimensions of all core elements in the model to determine the
    appropriate size of the bounding box used in LAMMPS simulations.
    Note that when used to determine the bounding box for a simulation
    using the pour LAMMPS fix, the bounding box is extended in the
    positive z-direction, to allow for a temporary insertion region to
    be added.

    Parameters
    ----------
    sim_block : Sim object
        Sim object created from parameters in the input file for ghastly.
    pour : bool
        Default False.  Whether or not the LAMMPS simulation the bounds
        are being generated for is using the pour fix in LAMMPS.

    Returns
    -------
    bound_limits : dict
        Dictionary with key:value pairs in the form of
        {'xb_min':xmin, 'xb_max':xmax, ... , 'zb_max':zmax}
    '''

    core_list = (sim_block.core_inlet |
                 sim_block.core_main |
                 sim_block.core_outlet)
    x_list = []
    y_list = []
    z_list = []
    for element in core_list.values():
        z_list += [element.zmin, element.zmax]
        if type(element) == ghastly.core.CylCore:
            x_list += [(element.x_c - element.r),
                       (element.x_c + element.r)]
            y_list += [(element.y_c - element.r),
                       (element.y_c + element.r)]
        elif type(element) == ghastly.core.ConeCore:
            x_list += [(element.x_c - element.r_major),
                       (element.x_c + element.r_major),
                       (element.x_c - element.r_minor),
                       (element.x_c + element.r_minor)]
            y_list += [(element.y_c - element.r_major),
                       (element.y_c + element.r_major),
                       (element.y_c - element.r_minor),
                       (element.y_c + element.r_minor)]
    f = 5.0
    match pour:
        case True:
            f_zup = 10.0
        case _:
            f_zup = 5.0
    bound_limits = {'xb_min' : min(x_list) - f*sim_block.r_pebble,
                    'xb_max' : max(x_list) + f*sim_block.r_pebble,
                    'yb_min' : min(y_list) - f*sim_block.r_pebble,
                    'yb_max' : max(y_list) + f*sim_block.r_pebble,
                    'zb_min' : min(z_list) - f*sim_block.r_pebble,
                    'zb_max' : max(z_list) + f_zup*sim_block.r_pebble}

    return bound_limits

def recirc_pebbles(input_file, init_bed_file,
                   recirc_file, recirc_template, 
                   var_file="recirc_var.txt"):
    '''
    Reads Ghastly input_file in order to generate a LAMMPS input file
    that will recirculate pebbles at the desired level of fidelity

    Parameters
    ----------
    input_file : str
        Path to input_file to be used, containing user-defined parameters for
        a Ghastly recirculation simulation
    init_bed_file : str
        Path to the LAMMPS dump file that contains the
        id, type, and x y z centroid coordinates of each pebble in the
        initial pebble bed, which should be settled, and filled to the desired
        packing fraction.  Note that the write_lammps_dump_file function can
        be used to generate an appropriately-formatted LAMMPS dump file from
        an numpy array of pebble centroid coordinates.
    recirc_file : str
        Filename for the recirculating LAMMPS input file that
        Ghastly generates.
    recirc_template : str
        Filename of the main recirculation template.  Note that
        custom templates should be located in the ghastly/templates/
        directory.
    var_file : str
        Optional. File name for LAMMPS variable block file generated by
        Ghastly.

    Returns
    ----------
    This function does not return any values, but it will generate a series
    of output files.  The one that should be run in order to start the
    recirculation simulation is the file with a name matching input_file.
    '''
    input_block = read_input.InputBlock(input_file)
    sim_block = input_block.create_obj()

    bound_limits = find_box_bounds(sim_block)

    _write_variable_block(var_file, input_block, sim_block)

    active_core = (sim_block.core_inlet |
                   sim_block.core_main |
                   sim_block.core_outlet)

    reg_files, reg_names = write_region_blocks(active_core)

    #note for tomorrow: this needs to be refactored to account for
    #other changes to the main recirc template/methods, on top of using
    #the templater instead.  For example, for very-high fidelity, you
    #need to autogen that little outlet cone that drops one peb at
    #a time

    #also note for tomorrow: instead of passing params = params in .render()
    #and then having everything in the template be {{param.key}}, looking
    #over the docs again I think you can just do blah.render(params) and then
    #use {{key}} directly in the templates.  if that works it'd be easier,
    #but you'll have to change how the variable template works, I think?
    #then you could do the thing of having a single running params dict you
    #pass to the templater for each file you need made (except the regions,
    #which need to be param'd separately bc. they'd overwrite each other

    main_cyl = {key: value for key, value in sim_block.core_main.items() if
                'cyl' in key}
    out_cyl = {key: value for key, value in sim_block.core_outlet.items() if
               'cyl' in key}
    _, out_params = out_cyl.popitem()
    r_chute = out_params.r
    v_reg_file = "v_regs.txt"
    v_reg_name = "v_reg"
    write_v_regs(main_cyl, r_chute, v_reg_file, v_reg_name)

    if sim_block.fidelity == 1:
        write_recircf1_main(recirc_file, recirc_template, var_file,
                            act_reg_files, act_reg_names,
                            v_reg_file, v_reg_name,
                            init_bed_file, sim_block, x_b, y_b, z_b)
    elif sim_block.fidelity == 2:
        outlet_zone = {key: value for key, value in
                       sim_block.recirc.items() if 'out' in key}
        outlet_file = 'f2-recirc-zone.txt'
        outlet_name = list(outlet_zone.keys())[0]
        write_recircf2_regs(outlet_zone, outlet_file)

        write_recircf2_main(recirc_file, recirc_template, var_file,
                            act_reg_files, act_reg_names,
                            v_reg_file, v_reg_name,
                            outlet_file, outlet_name,
                            init_bed_file, sim_block, x_b, y_b, z_b)
    return sim_block



def write_lammps_dump_file(coords, bound_conds, bound_limits, dump_file,
                           timestep = 0,
                           dump_template = "lammps/dump_template.txt"):
    '''
    Using the coordinate array and simulation boundary conditions and
    dimentions, this function uses a jinja template
    to create a LAMMPS dumpfile that be read into LAMMPS.

    Parameters
    ----------
    coords : list
        List of pebble centroid coordinates.
    dump_file : str
        Desired name of LAMMPS dumpfile created.  Please see LAMMPS read dump
        documentation for a full list of acceptable dump file types.
    bound_conds : str
        String providing the exact surface boundary conditions to be used
        in the LAMMPS bounding box.  See LAMMPS documentation for more
        information on bounding box conditions.
    bound_limits : dict
        Dictionary with key:value pairs in the form of 
        {'xb_min':xmin, 'xb_max':xmax, ... , 'zb_max':zmax}
    timestep : int
        Timestep to use inside dump file.  Default is 0.
    dump_template : string
        File name for template to be used.  Default is lammps/dump_template.txt

    Returns
    -------
    dump_file : file
        Generated file with the same name as dump_file.
    '''

    pebble_coords = [{"id": i, "x": v[0], "y": v[1], "z": v[2]}
                     for i, v in enumerate(coords)]
    params = {'timestep' : timestep,
              'boundary' : bound_conds,
              'coords' : pebble_coords,
              'n_pebbles' : len(coords)} | bound_limits
    _templater(params, dump_template, dump_file)

    return


def _write_variable_block(variable_file, input_block, sim_block, 
                         variable_template = "lammps/variable_template.txt"):
    '''
    Create the file containing LAMMPS variables, which can later be included
    in a main LAMMPS input.

    Parameters
    ----------
    variable_file : str
        The name of the variable block file to be created.
    input_block : Ghastly InputBlock object
        Ghastly object made from reading a Ghastly input file.
    sim_block : Ghastly Sim object
        Object containing simulation-specific information.

    Returns
    -------
    variable_file : file
        Generated file with the same name as variable_file.
    '''

    variables = input_block.lammps_var
    variables["t_final"] = sim_block.t_final
    variables["r_pebble"] = sim_block.r_pebble
    variables["seed"] = sim_block.seed
    variables["recirc_target"] = sim_block.recirc_target
    variables["recirc_hz"] = sim_block.recirc_hz

    _templater(variables, variable_template, variable_file)



def _write_region_blocks(core_zones, 
                        cyl_template = "lammps/cylcore_template.txt", 
                        cone_template = "lammps/conecore_template.txt"):
    '''
    Creates region block LAMMPS files for each core element in the core zones
    passed to this function, which can be included in a main LAMMPS file.

    Parameters
    ----------
    core_zones : dict
        Dictionary with key:value pairs where each key is the name of a core
        element, and each value is a Ghastly Core object containing that
        element's parameters.

    Returns
    -------
    reg_files : list
        List of the files for each region block generated.
    reg_names : list
        List of the element names for each region block generated, which is
        used as the region's name in LAMMPS.
    '''

    reg_files = []
    reg_names = []
    for element_name, element in core_zones.items():
        reg_names.append(str(element_name))
        reg_file = str(element_name)+"_region.txt"
        reg_files.append(reg_file)
        params = {'name' : element_name,
                  'x_c' : element.x_c,
                  'y_c' : element.y_c,
                  'zmin' : element.zmin,
                  'zmax' : element.zmax,
                  'open_bottom' : element.open_bottom,
                  'open_top' : element.open_top}
        if type(element) == ghastly.core.CylCore:
            params['r'] = element.r
            _templater(params, cyl_template, reg_file)

        elif type(element) == ghastly.core.ConeCore:
            params['r_major'] = element.r_major
            params['r_minor'] = element.r_minor
            _templater(params, cone_template, reg_file)

        else:
            raise TypeError(str(element_name)+" is not a CylCore or ConeCore.")
    return reg_files, reg_names


def _write_settle_block(settle_file, sim_block, reg_files, reg_names):
    '''
    Write lammps code block that adds the outlet region to the simulation
    and reverses gravity, allowing pebbles to settle upwards after pouring
    for upwards flowing systems.

    Parameters
    ----------
    settle_file : str
        Name of the LAMMPS input file that will be created.
    sim_block : Ghastly Sim object
        Ghastly Sim object containing simulation-specific parameters.
        Generally created automatically from an input file.
    reg_files : list
        List of strings, where each string is the list of region files that
        have been created during the automatic input file creation process.
    reg_names : list
        List of strings, where each string is the ID of the region
        corresponding to the region file with the same index in reg_files.

    Returns
    -------
    settle_file : file
        Generated file with the same name as settle_file.
    '''

    out_reg_files, out_reg_names = write_region_blocks(sim_block.core_outlet)
    out_reg_names += reg_names

    settle_template = env.get_template("settle_template.txt")
    settle_text = settle_template.render(out_reg_files=out_reg_files,
                                         n_regions=len(out_reg_names),
                                         region_names=out_reg_names)

    with open(settle_file, mode='w') as f:
        f.write(settle_text)
    return settle_text


def _write_pour_main(pour_file, sim_block, variable_file, x_b, y_b, z_b,
                    reg_files, reg_names, pebbles_left):
    '''
    Create the main LAMMPS file for pouring pebbles into the core.

    Parameters
    ----------
    pour_file : str
        Name of the main pour file to be created.
    sim_block : Ghastly Sim object
        Sim class object with simulation-specific parameters.
    variable_file : str
        Name of the file containing the LAMMPS variable block
    x_b : dict
        Dictionary with key: value pairs giving the upper and lower
        bounds in the x-direction for the bounding box.
    y_b : dict
        As x_b, but for the y-direction.
    z_b : dict
        As x_b but for the z-direction.
    reg_files : list
        A list of the files for the region blocks in LAMMPS.
    reg_names : list
        A list of the names of the regions used in LAMMPS.
    pebbles_left : int
        Number of pebbles that LAMMPS will be pouring.

    Returns
    -------
    pour_file : file
        Generated file with the same name as pour_file.
    '''

    main_core_zmax = max([(key, element.zmax)
                           for key, element in sim_block.core_main.items()])
    main_inlet = sim_block.core_main[main_core_zmax[0]]

    x_c_pour = main_inlet.x_c
    y_c_pour = main_inlet.y_c
    zmax_pour = z_b["max"] - 0.01
    zmin_pour = main_core_zmax[1] + 0.01

    if type(main_inlet) == ghastly.core.CylCore:
        r_pour = 0.75*main_inlet.r
    elif type(main_inlet) == ghastly.core.ConeCore:
        r_pour = 0.75*main_inlet.r_major

    match sim_block.down_flow:
        case True:
            settle = ""
        case _:
            write_settle_block("settle.txt", sim_block, reg_files, reg_names)
            settle = "include           settle.txt"

    main_template = env.get_template("pour_main.txt")
    main_text = main_template.render(variable_file=variable_file,
                                     x_b=x_b,
                                     y_b=y_b,
                                     z_b=z_b,
                                     region_files=reg_files,
                                     n_regions=len(reg_files),
                                     region_names=reg_names,
                                     x_c_pour=x_c_pour,
                                     y_c_pour=y_c_pour,
                                     r_pour=r_pour,
                                     zmin_pour=zmin_pour,
                                     zmax_pour=zmax_pour,
                                     pebbles_left=pebbles_left,
                                     settle=settle)

    pour_file = "pour_main_input.txt"
    with open(pour_file, mode='w') as f:
        f.write(main_text)
    return main_text


def _write_recircf2_regs(outlet_zone, outlet_file):
    '''
    Writes file for the recirculation region used to select which pebbles
    should be recirculated each loop in LAMMPS.  This region is non-physical.

    Parameters
    ----------
    outlet_zone : dict
        dictionary where the key is the
        name of the recirculation outlet zone and
        the value is the Ghastly Core object that defines
        this region.
    outlet_file : str
        file name of the recirculation outlet zone region block.

    Returns
    ----------
    This function has no return, but does generate a file named outlet_file.
    '''

    outlet_template = env.get_template("recircf2_outlet_template.txt")
    name, param = outlet_zone.popitem()
    outlet_text = outlet_template.render(outlet_name=name,
                                         x_c=param.x_c,
                                         y_c=param.y_c,
                                         r=param.r,
                                         zmin=param.zmin,
                                         zmax=param.zmax)
    with open(outlet_file, mode='w') as f:
        f.write(outlet_text)
    return outlet_text


def _write_v_regs(main_cyl, r_chute, v_reg_file, v_reg_name):
    '''
    Writes a file containing region blocks used for dumping velocity
    information by-region in the main core.  These are non-physical regions.

    Parameters
    ----------
    main_cyl : dict
        dict where the key:value pair is the name of the region comprising
        the main cylindrical portion of the core: the Ghastly Core object
        defining this region.
    r_chute : float
        the radius of the chute, in units matching the distance units used in
        LAMMPS (by default, Ghastly uses SI units, which uses meters).
    v_reg_file: str
        Filename of the velocity region input block file that this function
        generates.
    v_reg_name : str
        Base region name for the velocity regions.  As there are multiple
        sub-regions that need to be defined, then made into one union,
        sub-regions are labeled [v_reg_name]_1, [v_reg_name]_2, etc.

    Returns
    ----------
    This function has no returns, but does generate a file named v_reg_file.
    '''
    v_reg_template = env.get_template("velreg_template.txt")
    _, param = main_cyl.popitem()
    v_reg_text = v_reg_template.render(r_wall=param.r,
                                       v_reg_name=v_reg_name,
                                       x_c=param.x_c,
                                       y_c=param.y_c,
                                       r_chute=r_chute,
                                       zmin=param.zmin,
                                       zmax=param.zmax)
    with open(v_reg_file, mode='w') as f:
        f.write(v_reg_text)
    return v_reg_text


def _write_recircf2_main(recirc_file, recirc_template, var_file,
                        act_reg_files, act_reg_names,
                        v_reg_file, v_reg_name,
                        outlet_file, outlet_name,
                        init_bed_file, sim_block, x_b, y_b, z_b):
    '''
    Uses the main F2 template and the files containing smaller blocks of the
    LAMMPS model to create the main F2 recirculation file.

    Parameters
    ----------
    recirc_file : str
        Name of generated LAMMPS input file.
    recirc_template : str
        Filename of the F2 recirculation template to be used.
    var_file : str
        Filename of a previously-generated variable block.
    act_reg_files : list of str
        List of previously-generated files for the region blocks defining
        the physical bounds of the active core.
    act_reg_names : list of str
        List of the name of each region that defines the active core.  Must
        match names of regions in the act_reg_files.
    v_reg_file : str
        Filename of a previously-generated velocity regions file.
    v_reg_name : str
        Base name of the velocity regions.
    outlet_file : str
        Filename of a previously-generated region block that defines the
        zone that pebbles are pulled from when recirculating.
    outlet_name : str
        Name of the outlet recirculation region defined in outlet_file.
    init_bed_file : str
        Filename of LAMMPS dump file containing pebble bed starting positions.
    sim_block : Ghastly Sim object
        Sim object holding simulation-wide parameters for the current problem.
    x_b, y_b, z_b : dict
        dicts with 2 key:value pairs, each defining the min and max of the
        simulation's bounding box on their respective axis.

    Returns
    ----------
    This function has no returns, but does output a file named recirc_file.
    '''

    main_template = env.get_template(recirc_template)
    main_text = main_template.render(variable_file=var_file,
                                     x_b=x_b, y_b=y_b, z_b=z_b,
                                     region_files=act_reg_files,
                                     n_regions=len(act_reg_files),
                                     region_names=act_reg_names,
                                     v_reg_file=v_reg_file,
                                     v_reg_name=v_reg_name,
                                     starting_bed=init_bed_file,
                                     outlet_file=outlet_file,
                                     outlet_name=outlet_name)

    with open(recirc_file, mode='w') as f:
        f.write(main_text)
    return main_text


def _write_recircf1_main(recirc_file, recirc_template, var_file,
                        act_reg_files, act_reg_names,
                        v_reg_file, v_reg_name,
                        init_bed_file, sim_block, x_b, y_b, z_b):
    '''
    write recirc main file for LAMMPS

    Parameters
    ----------
    recirc_file : str
        Name of generated LAMMPS input file.
    recirc_template : str
        Filename of the F2 recirculation template to be used.
    var_file : str
        Filename of a previously-generated variable block.
    act_reg_files : list of str
        List of previously-generated filenames for the region blocks defining
        the physical bounds of the active core.
    act_reg_names : list of str
        List of the name of each region that defines the active core.  Must
        match names of regions in the act_reg_files.
    v_reg_file : str
        Filename of a previously-generated velocity regions file.
    v_reg_name : str
        Base name of the velocity regions.
    init_bed_file : str
        Filename of LAMMPS dump file containing pebble bed starting positions.
    sim_block : Ghastly Sim object
        Sim object holding simulation-wide parameters for the current problem.
    x_b, y_b, z_b : dict
        dicts with 2 key:value pairs, each defining the min and max of the
        simulation's bounding box on their respective axis.

    Returns
    ----------
    This function has no returns, but does output a file named recirc_file.

    '''

    main_template = env.get_template(recirc_template)
    main_text = main_template.render(variable_file=var_file,
                                     x_b=x_b, y_b=y_b, z_b=z_b,
                                     region_files=act_reg_files,
                                     n_regions=len(act_reg_files),
                                     region_names=act_reg_names,
                                     v_reg_file=v_reg_file,
                                     v_reg_name=v_reg_name,
                                     starting_bed=init_bed_file)

    with open(recirc_file, mode='w') as f:
        f.write(main_text)
    return main_text

def _templater(params, template_name, file):
    '''
    given text dict and template file name, create file
    '''
    
    template = env.get_template(template_name)
    text = template.render(params)
    with open(file, mode='w') as f:
        f.write(text)
    return text



    


